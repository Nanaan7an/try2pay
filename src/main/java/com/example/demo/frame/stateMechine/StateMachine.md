# Spring StateMachine

### 相关概念
* Transition: 状态转移节点，是组成状态机引擎的核心。
* source/from：现态。
* target/to：次态。
* event/trigger：触发节点从现态转移到次态的动作，这里也可能是一个timer。
* guard/when：状态迁移前的校验，执行于action前。
* action：用于实现当前节点对应的业务逻辑处理。

### 实战
以支付流水状态变迁为例</br>
本例的业务流程如下：
* 前提：已下单，待开启支付流程
1. 提交支付，生成支付流水；此时状态为I；
2. 用户不支付，关闭支付流水，状态为C；
2. 用户支付，支付信息提交至通道，此时状态为P；
3. 通道处理结束，状态为S/F；
4. 支付成功后的流水，用户可以申请退款，退款成功后状态为R。

### 开发流程（单例模式）
1. 定义状态枚举类`PayStateEnum`与事件枚举类`PayEventEnum`
2. 定义状态机配置类`PayStateMachineConfig`，规定状态机的初始状态、状态之间的事件转换
3. 定义业务处理类`PayEventConfig`
4. 定义状态机执行类`ExeChange`
5. 在Service中执行业务流程

### 开发流程（工厂模式）
1. 定义状态枚举类`PayStateEnum`与事件枚举类`PayEventEnum`
2. 定义状态机配置类`PayFactoryStateMachineBuilder`，定义状态机的初始状态、状态之间的事件转换
3. 定义业务处理类`PayFactoryEventConfig`

### 分支
在实际的业务场景中，业务对象的状态变迁并不是一个简单的链表式的，往往带有分支。

在分支复杂的情况下，若只是简单地定义不同的事件表示每一个状态迁移，一是这种代码不够优雅简洁，二是这种分支判断，完全依靠开发者的主观判断去调用某个事件，而不是使用代码逻辑判断如何执行。

需要用到的是`.withChoice()`。
* ##### 定义的内容
`.withExternal()`定义外部事件触发状态转换的方式，即某个状态变迁中的源状态、目的状态和该种状态迁移对应的事件。

`.withChoice()`定义的是某个状态变迁中的源状态、分支判断条件`Guard`、不同分支下的目的状态和对应的处理`Action`。

* ##### 执行过程
在使用状态机时，一般通过`sendEvent()`发送事件，根据当前状态和事件可以触发一个转换，一般指`.withExternal()`中的内容；当执行完`.withExternal()`的状态迁移之后，若状态机的当前状态处于`.withChoice()`定义的源状态时，则直接触发定义中的`Guard`并执行相关处理`Action`。

* ##### 常见误区
在定义`.withChoice()`后，开发者一般不能直接通过外部事件调用此处定义的选择逻辑，它通常是某种状态下的条件评估，也就是说，当状态机的当前状态满足定义的状态时，由状态机直接执行。

这也就是说，当需要使用分支的时候，除了原本的状态，还需要新定义一个中间状态，这个中间状态只是用来触发选择分支，它本身没有任何实际意义。

### tips
只有执行了业务处理事件类中的方法，才能改变业务对象的状态值；否则，只执行事件，只会改变状态机的状态值。一般来讲，改变业务对象状态的方法是在事件处理类的方法中使用`setter`，这也就表明，业务对象的状态值实际上是由开发者手动处理的，而不是由状态机赋值；所以本质上来讲，状态机在控制业务对象如何转换状态，而不是直接修改业务对象。

### 注意事项
状态机存在多种模式，单例模式【使用`config`】，即全局共用一个状态机实例；以及工厂模式【使用`builder`】，即每次获取状态机时创建一个状态机实例，多个状态机共存，使用ID进行区分。

使用工厂模式时，每次请求`exeChange()`（即调用`start()`方法），都会创建一个新的状态机，即绑定了状态机和请求，这样显然是不合理的，应当绑定业务对象和请求，即持久化。

但是持久化一般指持久化到本地内存或者缓存中，在遇到故障或者重启时，持久化的意义不大。

在开发中常用的是在中间状态时继续执行状态机，从数据库中读取当前状态并继续执行状态机，即业务流程中并非从初始状态开始一直不间断在一个线程中执行到终止状态

### 复习路线
`ExeChange`->`ExeFactoryChange`


